Author: SANG VO
Created Date: 2020/06/19
TOPIC: Javascript
Note: Design Pattern
-------------------------------------------------------------------------------
I. Creational Pattern:
1.1 Factory Pattern
1.2 Abstract Factory Pattern
1.3 Singleton Pattern
1.4 Prototype Pattern
II. Structural Pattern:
2.1 Adapter Pattern
2.2 Bridge Pattern
2.3 Composition Pattern
III. Behavior Pattern
3.1 Iterator Pattern
3.2 Observer Pattern
3.3 Strategy Pattern
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
I. Creational Pattern:
1.1 Factory Pattern
Useful:
	+ Define an interface or abstract class for creating an object 
	+ Let "the subclasses decide which class to instantiate".
Sample:
	--------------------------------
	<<abstractclass>> Car 
	--------------------------------
	Lexus 	(ExtendClass)
	Toyota 	(ExtendClass)
	Honda 	(ExtendClass)
	--------------------------------
	USING: 
	GetCarFactory {
		// Decide to  get an instance object (extendClass)
		public Car getCar(String carStyle) {
		// ... => create new object depend on carStyle parameter 
		}
	}
------------------------------------
1.2 Abstract Factory Pattern
Useful:
	In sample (1); 
	
Sample:
	----------------------------------------------------------------
	<<abstractclass>> AbstractFactory	
	<<abstract>> Car getCar();
	<<abstract>> BikeCycle getBikeCycle();
	--------------------------------
	<<abstractclass>> Car 			(AbstractFactoryClass)
	Lexus 	(ExtendClass)
	Toyota 	(ExtendClass)
	Honda 	(ExtendClass
	--------------------------------
	=> GetCarFactory Class
	{
	public Car getCar(String parameterCar) { => Create New object}
	}
	--------------------------------
	<<abstractclass>> BikeCycle 	(AbstractFactoryClass)
	NiTrek 	(ExtendClass)
	Giant  	(ExtendClass)
	Scott  	(ExtendClass)
	--------------------------------
	=> GetBikeCycleFactory Class	
	{
	public BikeCycle getBikeCycle(String parameterBikeCycle) { => Create New object}
	}
	-------------------------------- (***)
	<<Class>> FactoryCreator 
 	{
		Public AbstractFactory getFactory(String choice){}
	}
	----------------------------------------------------------------
	USING: 
	objVehicle {
		// Decide to  get an instance object (Car or BikeCycle)
	}

-------------------------------------------------------------------------------
1.3 Singleton Pattern
Useful:
	+ Define a class that has "only one instance"
	+ And provides a global point of access to it
Sample:
	class A{  
	 private static A obj=new A();//Early, instance will be created at load time  
	 private A(){}  
	   
	 public static A getA(){  
	  return obj;  
	 }  
	  
	 public void doSomething(){  
	 //write your code  
	 }  
	}  
-------------------------------------------------------------------------------
1.4 Prototype Pattern
Useful:
	+ Cloning of an existing object instead of creating new one 
	+ And can also be customized as per the requirement.
	
Sample:
	--------------------------------
	Interface Prototype {
		Public Prototype getClone();
	}
	--------------------------------
	<<classImplement>> EmployeeRecord implements Prototype {
		Private intCheckIn;
		// Constructor
		Public EmployeeRecord(intCheckIn) {
			this.intCheckIn = intCheckIn + 1;
		}
		
		public void showRecord() {
			System.out.println("Check-in times: " + this.intCheckIn);
		}
		
		@Override
		public Prototype getClone() {
			return new EmployeeRecord();
		}
	}
	--------------------------------
	USING: 
	objCar {
		EmployeeRecord e1=new EmployeeRecord(1);  
        e1.showRecord();  					// Show first record
        System.out.println("\n");  
        EmployeeRecord e2=(EmployeeRecord) e1.getClone();  
        e2.showRecord();   					// Show next record 
	}

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
II. Structural Pattern:
2.1 Adapter Pattern

-------------------------------------------------------------------------------
2.2 Bridge Pattern

-------------------------------------------------------------------------------
2.3 Composition Pattern

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
III. Behavior Pattern
3.1 Iterator Pattern

-------------------------------------------------------------------------------
3.2 Observer 

-------------------------------------------------------------------------------
3.3 Strategy Pattern
